using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FluentValidation.Results;
using FluentValidation.TestHelper;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Migrations.Operations;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using NorthWindCoreLibrary.Classes.Helpers;
using NorthWindCoreLibrary.Data;
using NorthWindCoreLibrary.LanguageExtensions;
using NorthWindCoreLibrary.Models;
using NorthWindCoreUnitTest_InMemory.Base;
using NorthWindCoreUnitTest_InMemory.DataProvider;
using NorthWindCoreUnitTest_InMemory.ValidationClasses;

namespace NorthWindCoreUnitTest_InMemory
{
    [TestClass]
    public partial class MainTest : TestBase
    {
        /// <summary>
        /// Generate json files for in memory testing.
        /// Should only run this once then again any time
        /// one of the models changes
        /// </summary>
        /// <returns></returns>
        [TestMethod]
        //[Ignore]
        [TestTraits(Trait.JsonGeneration)]
        public async Task CreateJsonFilesTask()
        {
            await SerializeModelsToJson();
        }
        
        /// <summary>
        /// Mockup for adding a single <see cref="Customers"/>
        /// </summary>
        [TestMethod]
        [TestTraits(Trait.CRUD)]
        public void AddCustomerTest()
        {
            Context.Entry(SingleContact).State = EntityState.Added;

            var customer = new Customers()
            {
                CompanyName = "Karen's coffee shop",
                Contact = SingleContact,
                CountryIdentifier = 20, 
                CountryIdentifierNavigation = new Countries() { Name = "USA" }
            };

            Context.Entry(customer).State = EntityState.Added;

            var saveChangesCount = Context.SaveChanges();

            Assert.IsTrue(saveChangesCount == 2,
                "Expect one customer and one contact to be added.");

        }

        [TestMethod]
        [TestTraits(Trait.Relations)]
        public void LoadingRelations()
        {
            int customerIdentifier = 3;
            
            var expected = SqlOperations.GetCustomers(customerIdentifier);
            

            var singleCustomer = Context.Customers
                .Include(customer => customer.CountryIdentifierNavigation)
                .Include(customer => customer.Contact)
                .ThenInclude(contact => contact.ContactDevices)
                .FirstOrDefault(customer => customer.CustomerIdentifier == customerIdentifier);

            // ReSharper disable once PossibleNullReferenceException
            Assert.AreEqual(singleCustomer.CompanyName, expected.CompanyName);
            Assert.AreEqual(singleCustomer.CountryIdentifierNavigation.Name, expected.Country);
            Assert.AreEqual(singleCustomer.Contact.FirstName, expected.FirstName);
            Assert.AreEqual(singleCustomer.Contact.LastName, expected.LastName);
            
            Assert.AreEqual(singleCustomer.Contact.ContactDevices.FirstOrDefault().PhoneNumber, expected.ContactPhoneNumber);

        }

        [TestMethod]
        [TestTraits(Trait.CustomSorting)]
        public void CustomerCustomSort_City()
        {
            
            List<Customers> customersList = Context.Customers
                .Include(customer => customer.CountryIdentifierNavigation)
                .Include(customer => customer.Contact)
                .ThenInclude(contact => contact.ContactDevices)
                .ThenInclude(x => x.PhoneTypeIdentifierNavigation)
                .ToList()
                .SortByPropertyName("CompanyName", SortDirection.Descending);

            Assert.IsTrue(customersList.FirstOrDefault().City == "Warszawa");
            Assert.IsTrue(customersList.LastOrDefault().City == "Berlin");
            

        }

        /// <summary>
        /// Demonstrates obtaining the query generated by EF Core using non in-memory DbContext
        /// as <seealso cref="EntityFrameworkQueryableExtensions.ToQueryString"/> does not support This extension
        ///
        /// Entity Framework Core can reveal a query by setting up logging in a DbContext which means each LINQ
        /// statement will write it's query to the desired output e.g. log file (normally for production) or
        /// to the console (usually for debugging).
        ///
        /// So ToQueryString is something to use one a LINQ statement is not providing proper results which can
        /// happen with improper joins and/or a bad database design.
        ///
        /// Notes
        ///  - ToQueryString works without actually making a call to a database
        ///  - ToQueryString is new, there may be some spots where it does not work as intend
        /// </summary>
        [TestMethod]
        [TestTraits(Trait.Utility)]
        public void GetQueryString()
        {
            using var context = new NorthwindContext();
            var query = context.Customers
                .Include(customer => customer.CountryIdentifierNavigation)
                .Include(customer => customer.Contact)
                .ThenInclude(contact => contact.ContactDevices)
                .ThenInclude(x => x.PhoneTypeIdentifierNavigation).ToQueryString();
            
            Debug.WriteLine(query);
            
        }

        [TestMethod]
        [TestTraits(Trait.CRUD)]
        public void RemoveSingleCustomer()
        {
            
            Assert.IsTrue(DeleteCustomer());
        }

        /// <summary>
        /// Find by primary key
        /// </summary>
        [TestMethod]
        [TestTraits(Trait.AccessTrackedEntities)]
        public void FindByPrimaryKey()
        {
            var customer = Context.Customers.Find(3);
            Assert.IsTrue(customer.CompanyName == "Antonio Moreno Taquería");
        }

        #region Working with live data, same can be done with in-memory


        [TestMethod]
        [TestTraits(Trait.AccessTrackedEntities)]
        public void FindAndLoadSingleCollection()
        {
            using var context = new NorthwindContext();

            var customer = context.Customers.Find(3);
            Assert.IsTrue(customer.CompanyName == "Antonio Moreno Taquería");

            Assert.IsTrue(customer.Orders.Count == 0);
            context.Entry(customer).Collection(e => e.Orders).Load();
            Assert.IsTrue(customer.Orders.Count > 0);

        }

        /// <summary>
        /// Demonstrates modifying a entry state
        /// </summary>
        [TestMethod]
        [TestTraits(Trait.AccessTrackedEntities)]
        public void FindAndModifySingleEntry()
        {
            using var context = new NorthwindContext();

            var customer = context.Customers.Find(3);
            Assert.IsTrue(customer.CompanyName == "Antonio Moreno Taquería");
            Assert.IsTrue(context.Entry(customer).State == EntityState.Unchanged);

            customer.CompanyName = "ABC";
            Assert.IsTrue(context.Entry(customer).State == EntityState.Modified);
        }

        [TestMethod]
        [TestTraits(Trait.AccessTrackedEntities)]
        public void ChangeCurrentValueByType()
        {
            var expectedDate = new DateTime(2021, 7, 4);
            using var context = new NorthwindContext();

            /*
             * Get Customer by primary key
             */
            var customer = context.Customers.Find(3);

            /*
             * Rather than directly setting ModifiedDate we look for it via type
             * Note: DateTime will fail as ModifiedDate is nullable
             */
            foreach (var propertyEntry in context.Entry(customer).Properties)
            {

                if (propertyEntry.Metadata.ClrType == typeof(DateTime?))
                {
                    propertyEntry.CurrentValue = expectedDate;
                }
            }

            // Assert
            Assert.AreEqual(customer.ModifiedDate, expectedDate);


            /*
             * Get original values from the database
             */
            var originalCustomer = context.Customers.AsNoTracking()
                .FirstOrDefault(cust => cust.CustomerIdentifier == customer.CustomerIdentifier);

            /*
             * Revert to ModifiedDate original value
             */
            customer.ModifiedDate = originalCustomer.ModifiedDate;

            // Assert
            Assert.AreNotEqual(customer.ModifiedDate, expectedDate);

        }

        #endregion

        #region Basic fluent validation 

        /// <summary>
        /// No Assert required, on failure an exception is thrown
        /// </summary>
        [TestMethod]
        [TestTraits(Trait.FluentValidation)]
        public void ValidateCompanyNameIsNull()
        {

            var singleCustomers = new Customers() { CompanyName = null };
            TestValidationResult<Customers> result = customersValidator.TestValidate(singleCustomers);
            result.ShouldHaveValidationErrorFor(customer => customer.CompanyName);
            result.ShouldHaveValidationErrorFor(customer => customer.ModifiedDate);

        }
        
        /// <summary>
        /// Inspect violations
        /// </summary>
        [TestMethod]
        [TestTraits(Trait.FluentValidation)]
        public void ValidateCompanyNameIsNull_1()
        {

            var singleCustomers = new Customers() { CompanyName = null };


            ValidationResult results = customersValidator.Validate(singleCustomers);

            if (!results.IsValid)
            {
                foreach (var failure in results.Errors)
                {
                    Console.WriteLine($"Property {failure.PropertyName} failed validation. Error was: {failure.ErrorMessage}");
                }
            }

        }

        /// <summary>
        /// No Assert required, on failure an exception is thrown
        /// </summary>
        [TestMethod]
        [TestTraits(Trait.FluentValidation)]
        public void ValidateCompanyNameIsNotNull()
        {

            var singleCustomer = MockedInMemoryCustomers().FirstOrDefault();

            TestValidationResult<Customers> result = customersValidator1.TestValidate(singleCustomer);

            result.ShouldNotHaveAnyValidationErrors();

        }

        #endregion


    }
}
